---
title: 탈중앙화 앱(Dapp)에 대하여
date: 2024-12-12 11:27:00 +/-TTTT
categories: [Security, Building Ethereum Dapps]
tags: [security, blockchain, dapp]     # TAG names should always be lowercase
image:
  path: /assets/img/2024-12-12-dapp-introduction/0.png
  alt: <탈중앙화 앱(Dapp)에 대하여> 썸네일
---

# 디앱이란?

## 구조적 관점: 디앱 해부하기

> 클라이언트 측은 기존 중앙화 웹앱과 동일

### 서버측 : P2P 네트워크

탈중앙화 서버는 같은 코드를 실행하고 같은 블록체인 데이터베이스를 갖는 서버의 P2P 네트워크이다.

**주요 특징**
- 마스터 노드가 없어 중앙에서 조정하지 않음.
- 각 노드가 **피어 노드(간략히 피어)라고 하는 다른 노드 간에 직접 통신**함.

![img](/assets/img/2024-12-12-dapp-introduction/0.png){: w="400" }
_P2P 네트워크는 마스터 노드의 조정 없이 서로 직접 통신하는 노드로 구성됨._

### 이더리움 네트워크

> 참여자 노드 = 블록체인 데이터베이스 + 노드 클라이언트
{: .prompt-info}

모든 노드가 서로 동등하기 때문에, 이더리움 네트워크에서는 클라이언트와 서버에 명확한 구분이 없음.
- 각 노드는 다른 노드의 서버이지만 동시에 다른 노드의 클라이언트인 것.

#### Wire P2P 프로토콜

이더리움 클라이언트는 공통 클라이언트 인터페이스를 노출하고 와이어 **Wire라는 P2P 프로토콜**을 통해 통신함.

이 프로토콜은 네트워크를 통해 투표내역과 같은 **거래내역(transaction)**이나 투표내역이 쌓여 있는 **블록(block)** 데이터를 표준화된 방식으로 전송하도록 함.

이더리움 클라이언트는 **C++부터 Go까지 다양한 프로그래밍 언어로 작성된 구현체**로 존재. <br>
하지만 모두 **표준 클라이언트 인터페이스**와 **와이어 프로토콜**을 사용하므로 원활한 상호작용 가능.

#### 노드 클라이언트의 이점

- (비트코인 노드와 마찬가지로) 암호화폐 거래내역 및 블록을 네트워크에 전파 가능.
- 블록체인 데이터베이스에서 호스팅되는 애플리케이션 코드를 실행할 수 있음.

#### 프로그램 블록체인

따라서 이러한 관점에서 이더리움과 같은 플랫폼을 **"프로그램 블록체인"** 이라고 함.

- ex) 탈중앙화 투표 앱은 이더리움 블록체인에서 수행되는 다양한 스마트 컨트랙트로 구성됨.

### 네트워크 노드의 역할

#### 전체 노드 full node

거래내역을 수동으로 처리함. 블록체인 데이터베이스에서 읽어올 수는 있지만, 새로운 블록을 처리할 수는 없음.
- 다만 피어 노드에서 받은 블록을 자신의 로컬 블록체인에 추가할 수 있음.

피어노드에서 받은 블록체인의 블록의 정확성을 검증하기 위해서만 거래를 실행함.

> 투표앱의 경우

- full node는 동료로부터 받은 투표내역을 다른 동료에게 전파함.
- 받은 블록이 올바른지 검증하고 투표 디앱 스마트 컨트랙트를 실행하여 투표내역을 포함함.
- 그러나 전체 노드는 새로운 블록에 투표내역을 저장하지 않음.

#### 채굴 노드 mining node

거래내역을 적극적으로 처리함. 거래내역을 모아 새로운 블록에 저장함.

이더리움 플랫폼에서 지원하는 암호화폐인 "이더"를 보상 받기 위해 계산량이 많고 에너지가 많이 소요되는 작업을 수행하며, 그렇게 생성된 블록을 나머지 P2P 네트워크에 전파함.

> 여기서 **채굴**은, 새로운 블록을 블록체인에 추가하고 암호화폐를 보상으로 받는 과정을 뜻함.
{: .prompt-info}

## 거래 흐름: 거래 수명주기에 따른 관점

1. 사용자가 웹 화면에서 드롭다운 선택 박스로 된 투표 옵션 중 하나를 선택하고 [Vote]를 클릭함.
2. 자바스크립트 함수가 클릭 이벤트를 처리하고 선택된 투표 내역을 가져옴.
    - 그 뒤 다양한 web3.js 라이브러리 함수를 사용하여 투표 스마트 컨트랙트와 연결된 이더리움 노드와 연결하고 `castVote()` 함수를 호출함.
    - `castVote()`는 전자서명된 거래내역 메시지를 생성하여 사용자가 실제로 이것을 보낸 사람임을 증명함.
3. 연결된 로컬 이더리움 노드는 거래내역 메시지를 처리하고 검증한 뒤에 피어 노드로 전달함.
4. 피어 노드는 거래내역이 채굴 노드를 만날 때까지 거래내역을 계속 전파함. (전체 노드 : 채굴 노드의 비율에 따라 다르지만 상대적으로 빠르게 발생.)
    - 채굴 노드는 전체 노드와 동일한 2, 3 단계를 수행하며, 투표내역과 같은 거래내역 중 하나를 선택함.
    - 거래를 처리하기 위해 필요한 <u>전기 요금</u>보다 **많은 거래 수수료를 얻을 것으로 예상**되면 해당 거래내역은 수익성이 있다고 판단 가능.
    - 수익성이 있다고 판단되었다면 채굴 노드는 `castVote()`함수르 실행하고 블록체인에 거래내역을 먼저 저장하기 위해 다른 노드들과 경쟁함.
    - 경쟁에서 이긴 채굴 노드(암호화 문제를 성공적으로 해결한 채굴자)는 투표내역을 새로운 블록에 있는 다른 내역과 같이 모으고, 생성된 블록은 전체 노드/채굴 노드 상관없이 모든 피어 노드에 전달함.
5. 각 노드는 새로운 노드를 받게 되면 개별 거래 내역이 정상적인지, 전체 블록이 유효한지 여부를 검증.
    - 그 뒤, 블록에 존재하는 모든 거래내역을 처리함.(이 과정에서 계약 상태의 유효성을 암시적으로 확인함.)
유효성을 검사하는 것? ex) 투표 제출 로직 = 후보자가 투표할 수 있는 횟수 확인 + 투표 수가 등록된 유권자 수보다 크지 않은지 .. 등
    - 노드가 성공적으로 블록을 확인하면 해당 블록을 피어 노드로 전달함.
    - 전체 네트워크가 새 블록을 추가할 때까지 피어 노드는 동일한 검증 작업 및 전파 작업을 반복함.
6. (사용자 관점) 로컬 이더리움 노드는 새로운 블록을 수신하고 수신된 블록에 있는 모든 거래내역을 실행하여 검증함. 
    - 그 중 하나가 투표 트랜잭션. 검증이 성공적으로 완료되면 `VoteConfirmation` 이벤트를 발생시킴.
    - 이벤트는 디앱 웹 UI를 포함하여 해당 노드와 연결된 모든 클라이언트에 전파함.
7. 투표 웹 클라이언트의 자바스크립트 코드에는 VoteConfirmation 이벤트에 대한 콜백 함수가 포맣되어 있으며 이 이벤트가 완료되면 콜백 함수가 호출됨.
8. 마지막으로 콜백 함수는 사용자의 화면에 투표가 완료되었음을 표시함.

![img](/assets/img/2024-12-12-dapp-introduction/1.png){: w="450" }
_탈중앙화 투표 앱 전체 구조_

![img](/assets/img/2024-12-12-dapp-introduction/2.png){: w="450" }
_투표 흐름의 수명주기._

> **투표 흐름의 수명주기** <br>
> 투표자 브라우저가 이더리움 네트워크의 로컬 노드에서 투표 스마트 컨트랙트에 있는 castVote() 함수를 호출하면 투표내역이 생성됨. <br> 그런 다음 유효성 검사가 수행되고 채굴 노드에 의해 새로운 블록이 블록체인에 포함될 때까지 네트워크 전체에 전파됨. 새로운 블록은 네트워크 전체에 전파된 다음 최종적으로 로컬 노드로 되돌아옴.
{: .prompt-info}


## 디앱 용어

### 스마트 컨트랙트 smart contract

디지털 자산을 교환하는 둘 이상의 당사자 사이에서 이루어지는 계약.

- 당사자 중 한 명 또는 그 이상이 디지털 자산을 스마트 컨트랙트에 보냄으로써 그 계약이 활성화 됨.
- 그 뒤 디지털 자산은 사전에 정의되고 프로그래밍 된 규칙과 계약이 활성화된 상태에 따라서 다시 다른 사람에게 보내짐.

### 자율 개체 autonomous agent

외부 소프트웨어 서비스와 자율적으로 상호작용하는 소프트웨어 개체.

- 외부 환경에서 검증된 변경 사항에 따라 스스로 재구성하거나 심지어 재프로그램할 수 있음.

### 탈중앙화 조직 Decentralized organization

전통적인 **중앙화 조직**은 자산, 투자자, 직원 및 고객 등 다양한 계층의 개인으로 구성됨.
- 투자자는 조직 일부를 주식으로 소유하고 조직을 통제함.
- 다양한 계층에 있는 개인 간의 상호작용은 조직을 제어할 수 있는 권한에 따라 영향을 받음. <br> 
    ex) 직원은 투자자 또는 투자자가 직간접적으로 권한을 부여한 다른 직원이 채용함.

그에 반해 **탈중앙화 조직**은 어느 개인이나 주체에게 통제되지 않음. <br>
사전에 정의된 규칙이 조직을 구성하는 다양한 계층에 있는 개인 간의 상호작용을 결정함.

- 하지만 이러한 규칙 역시 특정 개인이 다른 사람보다 더 많은 권한을 갖도록 설계될 수는 있음.

### 탈중앙화 자율 조직 DAO : Decentralized Autonomous Organization

탈중앙화 조직이면서 자율 개체. 
- 외부 소프트웨어 서비스와 자율적으로 상호작용하는 소프트웨어 개체임.
- DAO와 관련된 개인은 미리 정의된 규칙을 바탕으로 DO처럼 상호작용함.

DO와의 큰 차이점
- DAO는 외부 주체 간의 상호작용이 대부분 자동화 되어있으며 상호작용 프로토콜이 스마트 컨트랙트로 프로그래밍 되어있음.    
    - DO의 외부 주체는 수동 프로토콜을 사용함.
- DAO는 상호작용이 자동화되어있으 예측할 수 있기 때문에 DO보다 더 신뢰할 수 있음.
    - DO는 수동 프로토콜을 기반으로 수행하는 개인의 평판에 상호작용을 전적으로 의존해야 함.

이러한 정의에 따르면 암호화폐를 지원하기 위한 목적으로 구축된 블록체인 플랫폼은 DAO 또는 DO로 분류될 수 있음.

### 탈중앙화 자율 기업 DAC : Decentralized Autonomous Corporation

DAO이면서 주식을 구매하여 기업의 일부를 소유할 수 있음. 
- 전통적인 기업(중앙화된 조직)과 마찬가지로 실적에 따라 주기적으로 배당금을 지불함.
- 반면에 DAO는 일반적으로 비영리 단체임. : 참여자는 생태계를 기여하고 내부 자본금을 증대시켜 경제적 이익을 독점하여 얻을 수 있음.

### 각 용어의 주요 특징 요약

|                       | 소프트웨어인가 | 자본금이 필요한가 | 자율적인가 | 소유할 수 있는가 |
|----------------------|------------|---------------|---------|--------------|
|자율 개체                |예          |아니요           | 예       | 아니요        |
|DO (탈중앙화 조직)          |아니요       |예              | 아니요     | 예         |
|DAO (탈중앙화 자율 조직)     |예          | 예            | 예         |아니요        |
|DAC (탈중앙화 자율 기업)     |예          | 예            | 예         |예     |


# 디앱 적용 사례

## 적절하지 않은 사례

다음 질문에 모두 예라고 대답할 수 있는 경우에만 블록체인을 도입하는 것이 의미가 있다.

- 당신의 앱에 공유 데이터베이스가 필요합니까?
- 다수의 사용자가 데이터베이스에 저장할 수 있습니까?
- 데이터베이스 사용자가 서로 신뢰하지 못하고 있습니까?
- 모든 사용자가 신뢰할 수 있는 중앙에서 통제하지 않고 사용자가 데이터베이스를 수정하려고 합니까?
- 사용자가 생성한 거래가 다른 거래들과 서로 협력하며 작용합니까?

이러한 기준에 따르면 **외부인에게 데이터를 노출하지 않는 사내용 앱은 디앱을 선택하는 것이 적절하지 않다.** <br>
또한 경영 규칙에 따라 **기밀성이 중요한 앱**이라면, 이 역시도 적절하지 못하다.

- 그 외에도 처리 속도에 관련한 기술적인 단점이 존재한다. (새로운 블록을 생성하는 데 대략 15초가 걸림.) <br>
    따라서 디엠 등 인스턴트 메세징 플랫폼 제작에 적절치 않다.

> 스마트 컨트랙트는 상호작용하는 모든 참여자에게 **완전히 개방적이고 투명**하다. 따라서 사용자를 **로직과 규칙에 접근하지 못하게 하거나, 이해하지 못하게 막는 것**은 디앱의 목적과 맞지 않는다.
{: .prompt-info}

# 5분 안에 디앱 구현하기

## 기본적인 암호화폐 심플코인 만들기

[remix ethereum (Web IDE)](https://remix.ethereum.org/#lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.4.24+commit.e67f0147.js&language=Solidity)
- version : soljson-v0.4.24+commit.e67f0147

```
pragma solidity ^0.4.0;

contract SimpleCoin {
    mapping (address => uint256) public coinBalance;

    constructor() public {
        coinBalance[0x5B38Da6a701c568545dCfcB03FcB875f56beddC4] = 10000;
    }

    function transfer(address _to, uint256 _amount) public {
        coinBalance[msg.sender] -= _amount;
        coinBalance[_to] += _amount;
    }
}
```

| 키워드 | 설명 |
|--|--|
|`contract`| 다른 프로그래밍 언어의 `class`와 유사함. |
|`mapping`| 해시 테이블 또는 해시 맵과 유사한 데이터 구조. `mapping (address => uint256)` 일 경우 키 : address, 값 : uint256 |
|`address`| 이더리움 사용자 계정 또는 컨트랙트 계정을 나타내는 20바이트 값 |
|`uint256`| 부호가 없는 256비트 정수 |
|`msg`| 수신된 메시지 객체를 나타내는 특수 변수 |
|`msg.sender`| 메시지 보낸 사람의 주소를 나타내는 msg 객체의 속성 |

## 컨트랙트 실행하기

다음과 같이 auto compile에 체크를 눌러준다.
- 참고로 컴파일러 버전도 여기서 변경할 수 있다. 최신 버전은 `soljson-v0.8.26+commit.8a97fa7a` 이지만, 책에 맞게 `soljson-v0.4.24+commit.e67f0147`로 설정하여 컴파일한다.

![img](/assets/img/2024-12-12-dapp-introduction/3.png){: w="400" }


그리고 Deploy&Run탭에 Deploy를 클릭하여 컨트랙트를 인스턴스화할 수 있다.

![img](/assets/img/2024-12-12-dapp-introduction/4.png){: w="400" }

컨트랙트는 **가상화된 이더리움 블록체인 주소**에 저장된다. Deploy&Run탭에 Deployed Contracts 패널을 통해 배포된 주소를 확인할 수 있다.

![img](/assets/img/2024-12-12-dapp-introduction/5.png){: w="400" }

## 컨트랙트 활용하기

이제 간단한 조작이 가능하다. SimpleCoin 잔액을 확인하고 토큰을 다른 계정으로 전송할 수 있다.

- **transfer** 는 쓰기 작업 (빨간색 버튼) : 생성자를 통해서 컨트랙트를 생성하거나 상태 변수를 수정하는 함수를 호출함.
    - coinBalance 상태 변수에 포함된 값을 변경함.
- **coinBalance** 는 읽기 작업(파란색 버튼) : 상태 변수를 확인하거나 읽기 전용 함수를 호출함
    - 계정의 잔고를 읽는 작업

![img](/assets/img/2024-12-12-dapp-introduction/6.png){: w="400" }

초기 생성자에서 "0x14743a09Acff6d2a60DcDF7aa4afF308fdDC160c" 주소에 10000토큰을 설정하였기 때문에, coinBalance에 해당 주소를 입력하면 10000이 표시되는 것을 확인할 수 있다.

![img](/assets/img/2024-12-12-dapp-introduction/7.png){: w="400" }

### 리믹스 테스트 계정 주소 목록 확인

Deploy & Run 탭 상단에 Account 드롭박스를 통해 몇가지 테스트 계정을 확인할 수 있다.

![img](/assets/img/2024-12-12-dapp-introduction/8.png){: w="400" }

- 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 | 잔액 : 10000
- 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2 | 잔액 : 0
- 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db | 잔액 : 0
- 0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB | 잔액 : 0
- 0x617F2E2fD72FD9D5503197092aC168c91465E7f2 | 잔액 : 0

등등..

하지만 생성자에서 설정해준 "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4" 계정을 제외한 계정들은 계정 잔액 (SimpleCoin)이 0으로 설정되어 있는 것을 확인할 수 있다.

### transfer 실행

transfer 작업을 사용하여 `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` 에서 150 토큰을 `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`로 보내보자.

먼저 account 드롭다운을 `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`로 설정해준다.

그리고 transfer에 다음과 같이 입력한다.
> 매개변수의 값은 쉼표로 구분한다.
```
"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2", 150
```

transfer 버튼을 누르면 아무런 결과를 반환하지 않는다.

하지만 각각 coinBalance를 통해 각 account의 잔액을 확인해보면?

![img](/assets/img/2024-12-12-dapp-introduction/9.png){: w="400" }
_`0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`의 잔액은 150_


![img](/assets/img/2024-12-12-dapp-introduction/10.png){: w="400" }
_`0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`의 잔액은 9850_

위와 같이 정상적으로 transfer가 실행되었음을 확인할 수 있다.

# 요약

- 탈중앙화 앱은 특정 주체가 소유하거나 제어하지 않고 신뢰가 필요 없는 분산 P2P 네트워크에서 실행되는 새로운 유형의 앱이다.
- 탈중앙화 앱의 구조는 비즈니스 로직과 데이터(블록체인)가 네트워크의 각 노드에서 완전히 복제되어 실행되기 때문에 기존의 중앙화된 앱의 구조와는 다르다.
- 탈중앙화 앱은 블록체인 기술을 기반으로 한다. 공개키 암호화, 해시 함수, 합의 알고리즘을 통한 채굴 기술등을 활용한다.
- 탈중앙화 앱을 적절하게 활용한 사례는 많다. 특히 원산지 및 진품 추적, 신원 확인, 규제 감사, 예측 시장 및 크라우드펀딩 분야에서 활용된다.
- 탈중앙화 앱이 비즈니스 문제를 해결하기에 항상 옳은 방법은 아니다. 예를 들어 외부 참여자와 정보를 공유할 수 없는 사내용 앱을 탈중앙화 하는 것은 목적에 맞지 않는다.
- 탈중앙화 앱의 핵심인 이더리움에서 스마트 컨트랙트를 자바스크립트와 비슷한 솔리디티로 구현할 수 있다. 리믹스 솔리디티 IDE를 사용하여 간단한 스마트 컨트랙트를 작성하고 활성화하여 테스트 이더리움 계정과 상호작용할 수 있다.


---

> 「Building Ethereum Dapps 이더리움 디앱 개발」 (로베르토 인판테 저, 정종화 역)을 읽고 작성한 글입니다.
{: .prompt-tip}