---
title: 블록체인 이해하기
date: 2024-12-12 16:07:00 +/-TTTT
categories: [Security, Blockchain]
tags: [security, blockchain, ethereum]     # TAG names should always be lowercase
math: true
---

# 디앱 자세히 살펴보기

## 이더리움 노드

![img](/assets/img/2024-12-12-blockchain-introduction/0.png){: w="400" }{: .shadow }
_이더리움 P2P 네트워크_

- **이더리움 클라이언트 Ethereum client** : 런타임 시 작동함.
    - **이더리움 가상머신 Ethereum Virtual Machine (EVM)** : 솔리디티나 EVM 바이트코드로 작성된 **스마트 컨트랙트를 실행**할 수 있다.
    - **메모리 풀 memory pool**: 노드가 수신한 **거래내역**을 네트워크에 전파하기 전에 저장함. <br>
        투표 앱에서는 **사용자가 제출한 투표내역**을 저장함.
    - **클라이언트 프로세스** : 수신된 메세지 및 거래내역을 적절하게 EVM에 보내거나 거래내역을 메모리 풀에 저장하고 검색함. <br>
    또한 <u>피어 노드에서 받은 블록을 처리</u>하고 블록체인 데이터베이스의 로컬 복사본에 추가.
    - **JSON-RPC API** : 다른 노드나 <u>외부에서 클라이언트의 기능을 사용할 수 있도록</u> 함.
- **블록체인 데이터베이스 blockchain database** : 유권자가 제출한 투표와 같은 거래내역 외에도 블록체인은 <u>네트워크 상에 배포된 모든 스마트 컨트랙트의 EVM 바이트코드 복사본과 상태를 저장</u>함. <br> 
    채굴 노드는 15초마다 정기적으로 새로운 블록을 블록체인에 추가함.

## 거래내역 수명주기 다시 보기

### Local full node

![img](/assets/img/2024-12-12-blockchain-introduction/1.png){: w="500" }{: .shadow }

거래내역은 JSON-RPC 인터페이스로 선택한 이더리움 노드의 스마트 컨트랙트에서 함수가 호출될 때 생성됨.

1. JSON-RPC 인터페이스로 선택된 이더리움 노드의 함수를 호출한다.
2. 함수는 스마트 컨트랙트를 실행하고 투표 거래내역이 생성된다.
3. 노드는 거래 내역을 **메모리 풀**에 저장한다.
4. 전체 노드가 **유효성 검사**를 위해 **EVM에서 거래 내역을 실행**한다.
5. 검증된 거래는 피어 노드로 전파한다. 유효하지 않은 거래내역일 경우 노드는 거래내역을 전파하지 않고 폐기함.

### Mining node

![img](/assets/img/2024-12-12-blockchain-introduction/2.png){: w="500" }{: .shadow }

1. 채굴 노드는 피어 노드에서 수신된 거래 내역을 메모리 풀에 저장한다.
2. 채굴 노드가 메모리 풀에서 **수익성이 높은 거래내역을 선택**하여 EVM에서 실행한 뒤, 유효한 거래 내역을 새 블록에 추가한다.
3. 생성된 블록이 블록체인에 성공적으로 추가되면 채굴 노드는 관련된 거래내역을 **메모리 풀에서 제거**한다.
4. 새로운 블록은 피어 노드를 통해 전파한다.

### Full node

![img](/assets/img/2024-12-12-blockchain-introduction/3.png){: w="500" }{: .shadow }

1. 전체 노드는 피어 노드에서 새로운 블록을 수신한다.
2. 유효성 검사를 위해 EVM에서 모든 블록의 거래내역을 실행한다.
3. 노드는 블록이 모두 검증되면 관련된 모든 거래내역을 메모리 풀에서 제거한다.
4. 노드는 블록을 피어 노드로 전파한다.

## 개발 관점: 투표 앱 스마트 컨트랙트 배포하기

![img](/assets/img/2024-12-12-blockchain-introduction/4.png){: w="500" }{: .shadow }

1. 이더리움 스마트 컨트랙트는 솔리디티 언어로 코드를 작성함.
2. 먼저 코드를 EVM 바이트코드로 컴파일하여 로컬 이더리움 노드에서 실행함.
3. 컨트랙트 배포 트랜잭션으로 P2P 네트워크에 스마트 컨트랙트를 배포함.
4. 채굴 노드는 네트워크 전반에 전파되는 동안 배포 트랜잭션을 처리하고 EVM 바이트코드를 블록체인에 저장함.

# 디앱에 사용되는 기술

디앱은 블록체인이라는 **탈중앙화된 데이터베이스** 위에서 실행되는 **스마트 컨트랙트**에 **캡슐화된 비즈니스 로직을 기반**으로 함.

> 기반 기술

- 공개키 암호화
- 암호화 해시 함수
- 합의 알고리즘
    - 작업 증명 proof of work
    - 지분 증명 proof of stake

## 블록체인 기술

### 공개키 암호화

한 쌍의 키를 기반으로 하는 암호화 방법.

일반적으로 임의로 생성되고 소유자만 알 수 있는 **개인키**와 개인키를 알고리즘으로 변환하여 모두가 알 수 있는 **공개키**가 있음.

![img](/assets/img/2024-12-12-blockchain-introduction/5.png){: w="500" }{: .shadow }
_개인키, 공개키 생성 과정_

#### 개인키와 공개키의 목적

- 공개키를 사용하여 암호화된 데이터를 복호화할 수 있다.
- 누군가가 문서에 디지털 서명을 할 수 있게 한다.
    - 개인키를 알고 있는 경우에만 **서명을 생성**할 수 있고,
    - 공개키를 알고 있는 사람은 **서명을 검증**할 수 있다. <br>
**스마트 컨트랙트 거래내역의 진위 여부는 이 디지털 서명을 사용한다.**

![img](/assets/img/2024-12-12-blockchain-introduction/6.png){: w="500" }{: .shadow }
_공개키와 개인키 쌍을 사용한 암호화 및 복호화_

> 블록체인 플랫폼에서 암호화폐는 일반적으로 공개키로 식별되는 계정에 저장된다. <br>
> 하지만 개인키를 달고 있는 경우에만 활용할 수 있다. <br>
> 따라서 개인키를 잊어버리면 아무도 해당 계정을 사용할 수 없으며, 계정의 암호화폐는 분실된 것으로 간주한다.
{: .prompt-info}

### 암호화 해시 함수

**해시 함수**는 임의 크기의 데이터를 고정 크기의 데이터로 매핑할 수 있는 함수.
- 고정크기의 데이터를 **해시** 또는 **다이제스트 digest**라고 함.

#### 암호화 해시 함수 cryptographic hash function의 특징
1. **결정론적 deterministic**임. 동일한 입력값은 항상 동일한 해시를 생성함.
2. **빠르게** 계산 가능
3. **일방향 함수**이며 **불가역적**임. <br>
    따라서 원래 데이터를 해시에서 추론할 수 있는 유일한 방법은 동일한 해시를 얻을 때까지 함수에 막대한 수의 입력값을 넣어볼 수 밖에 없음.
4. **두 개의 다른 입력값에서 값은 해시값이 나오는 경우가 거의 불가능**함. <br>
    물론 다른 두 개의 입력값에서 같은 해시값이 나올 수는 있으나, 무수히 대입해보지 않는 한 입력값을 알아낼 수 없음.
5. **입력값이 조금이라도 변경되면 전혀 다른 해시값이 생성**됨. <br>
    동일한 값을 함수에 넣지 않고는 의도적으로 동일한 해시 또는 비슷한 해시조차 얻을 수 없음.

#### 암호화 해시 함수 예시

은행은 다음 사진과 같이 지불 금액, 수령자, 세부 사항 등을 개인키(서명)와 함께입력값으로 넣어 해시값을 생성한다.

이 전자 수표를 나중에 수령하고자 한다면? 은행 계좌의 공개키와 전자 수표를 은행에 제출하면 
- 은행은 **전자서명**과 
- **수표의 세부 사항**, **개인키**가 일치하는지 검증함.

![img](/assets/img/2024-12-12-blockchain-introduction/7.png){: w="500" }{: .shadow }
_은행은 개인키와 수표의 세부내용으로 생성된 전자서명으로 전자수표를 보호함_


> 만약 위조된 전자 수표를 은행에 제출한다고 가정해보자.

전자서명은 암호화된 해시값이므로 **일치하는 전자 서명을 만들기 위해서는 위조되지 않은 원본의 전자 수표와 세부 내용이 동일**해야 함.

만약 해커 집단이 이 전자 수표를 가로채서 세부 내용을 변경하더라도??

1. 금액이나 수령인이 변경되면 **전혀 다른 전자서명이 생성**되므로 수표가 유효하지 않음을 은행에서 확인 가능
2. 해커가 바뀐 수표 내용으로 전자서명을 만들고자 하면 **개인키를 모르기 때문**에 이 역시도 불가능함.

위 두 사유로 인해 전자수표는 안전하다.

![img](/assets/img/2024-12-12-blockchain-introduction/8.png){: w="500" }{: .shadow }

#### 암호화 해시 함수와 블록체인

블록체인 거래는 위 예시와 비슷하다.

1. **공개키로 확인할 수 있는 계정**에서 거래가 발생한다.
2. 공개키로 확인할 수 있는 암호화폐의 수량, 수령인과 같은 **거래의 세부내역**을 가지고 있다.
3. 블록체인 거래내역에는 개인키를 통해 **계정 소유자가 거래내역을 입력해서 보냈다는 것을 증명**해주는 **전자서명**을 포함한다.

### 블록체인

**블록체인** : 거래내역을 담고 있는 **블록이 분산된 데이터베이스**.

<table>
    <tr>
        <td>
        <img width="400" src="/assets/img/2024-12-12-blockchain-introduction/9.png">
        </td>
        <td>
            <ul>
                <li>블록 체인 : 블록들이 연결된 것</li>
                <li>
                    블록
                    <ul>
                        <li>일련 번호 Block number</li>
                        <li>타임스탬프 Timestamp</li>
                        <li>이전 블록의 해시</li>
                        <li>전체 내용을 요약하는 암호화 해시</li>
                        <li>직전 블록의 암호화된 해시값 Previous block's hash 참조</li>
                        <li>전자서명된 거래 내역</li>
                    </ul>
                </li>
            </ul>
        </td>
    </tr>
</table>

**전자서명된 거래 내역**

하나의 블록은 출처를 증명하기 위해 전자서명된 거래 내역들을 포함하고 있음. <br>
대부분 타원곡선 암호화 기반의 **타원곡선 전자서명 알고리즘(ECDSA)**을 통해 서명함.
- Elliptic Curve Digital Signature Algorithm
- 전통적인 DSA보다 더 나은 성능


> 블록은 타임스탬프 / 이전 블록의 암호화 해시값 / 이전 블록의 해시 / 블록의 전체 내용을 요약하는 해시를 모두 갖고 있기에, <br>
> **현재 상태(최신 블록)**와 첫 거래가 생성된 이후 저장된 **모든 거래 내역**을 저장함. <br>
> 이러한 구조적인 특징은 **거래내역이 조작되거나 수정되지 않았다는 것을 보장**.
{: .prompt-tip}

![img](/assets/img/2024-12-12-blockchain-introduction/10.png){: w="500" }{: .shadow }

> 실제 비트코인에서 사용되는 머클 트리나 이더리움에서 사용되는 패트리샤 트리와 같이 실제 사용되는 블록체인 구조를 단순화한 버전

블록에 기록된 거래내역은 한 번 기록되면 수정할 수 없다.

수정하게 되면, **블록의 해시값을 다시 생성**해야 하는데, 다시 생성된 해시는 **연결된 블록에서 참조하고 있는 기존의 해시와 절대 같을 수가 없음**.

> **만약 두 거래내역이 서로 상충되는 경우** (ex) 한 계좌에 있는 모든 자금을 두 개 이상의 다른 계좌로 이체하려고 시도하는 '이중 지불 공격) **채굴자는 이더리움 네트워크 내에서 전연 변수 순서에 따라 먼저 들어온 거래를 처리**한다. <br>
> 두 번째 거래는 거부되어 다시는 블록체인 내에서 찾을 수 없다. <br>
> 모든 블록체인은 이 방법을 사용하며, 그렇지 않다면 블록체인이라고 할 수 없다.
{: .prompt-info}

블록체인은 P2P 네트워크를 통해 자율적으로 관리됨. P2P 네트워크는 장애 허용 없이 서비스를 제공하며, 각 노드는 모든 거래를 **탈중앙화된 합의를 통해 독립적으로 처리**함.

따라서 블록체인은 이벤트 기록을 영구적으로 기록하는 데 적합함.
- ex) 신원 관리, 거래내역 처리 및 출처 추적 등

### 채굴

P2P 네트워크로 블록체인 트랜잭션을 지속적으로 처리하려면 **합의 알고리즘**에 따라 **채굴 노드** 또는 **채굴자**라 부르는 처리 노드에 연산력에 관한 보상을 해줌.

- 연산력을 제공하는 데 드는 전기 비용을 간접적으로 보상해주는 것.
- 몇 초에 한 번씩 채굴에 성공한 채굴자는 플랫폼에서 지원하는 일정 수의 암호화폐를 지급받음.

### 합의

**합의** : 네트워크 참여자들이 **트랜잭션 처리 결과를 동의**하는 과정.

- 분산화 : 많은 이가 결정에 참여함.
- 무신뢰성 : 참여자끼리 신뢰하기 위해 노력할 필요가 없음.

합의 과정은 개별 트랜잭션이 아닌, 새로 생성되는 블록 단위로 이루어진다. <br>
참여자는 **새로운 블록이 유효한지 독립적으로 검증**하며 **검증된 블록은 나머지 네트워크로 전파**한다.

실제로 대부분의 참여자가 블록을 유효한 것으로 인정하고 네트워크 전체에 성공적으로 전파한 경우 채굴자는 해당 블록을 유효한 최신 블록으로 인정하고 이 블록위에 새로운 블록이 쌓이게 됨.

<br>

> 하지만 악의적인 채굴자가 잘못된 블록을 블록체인에 추가하고 피어노드에게 전파한다면?

피어 노드들은 **수신된 블록을 거부**하고, **잘못된 체인은 즉시 사라지게 되는 것**.
- 전체 노드가 피어 노드에 전파하기 전에 블록을 수정하고자 해도 같은 일이 발생함.

<br>

핵심은 **참여자 노드가 최신 블록을 검증하는 단계**.

하나에 블록에 존재하는 트랜잭션들의 전자서명을 모두 검증하고 참여자 노드는 블록의 해시값이 유효한지 검증함.
- 해시값은 합의된 프로토콜에 따라 채굴자에 의해 생성됨.

초기 이더리움은 <u>작업 증명 알고리즘</u>을 기반으로 한 **이더해시Ethash 합의 알고리즘**을 사용하였으나, 향후 <u>지분 증명 알고리즘</u>을 기반으로 한 **캐스퍼Casper 합의 알고리즘**을 사용할 예정.

### 작업 증명

블록은 **암호화된 해시**를 가지고 있음.
- 해시값은 블록의 속성 정보, 트랜잭션 데이터 등 블록의 모든 내용을 요약한 것.

해시값에는 **논스 nonce**라는 32비트 길이의 데이터도 포함되어 있다.

작업 증명 알고리즘에서 채굴자는 <u>특정 조건에 맞는 해시값인 논스값를 찾아야</u> 한다.

![img](/assets/img/2024-12-12-blockchain-introduction/11.png){: w="500" }{: .shadow }

예를 들어 위 그림처럼 해시값이 16진수 형식으로 표시될 때, (오른쪽 사진처럼) 논스값을 찾아 **0이 13개 선행되도록** (목표값 이하의) 64비트의 정수 해시를 제한하면 유효한 해시 수가 이론상 최대 수인 
**$$2^{64} -1 = 16^{16}-1 = 18,446,744,073,709,551,615$$**에서 **$$16^3 - 1 = 4095$$** 로 줄어들게 된다.

<br>

채굴자가 특정 논스를 찾을 수 있는 유일한 방법은 해시의 제약 조건이 충족될 때까지 **가능한 한 많은 값을 시도**하는 것.

조건에 맞는 해시가 발견되면 채굴자는 처리 중인 새 블록을 블록체인에 추가하고 토큰 보상을 청구할 수 있다.

CPU를 많이 사용하고 에너지를 많이 사용하여 경제적으로도 비용이 많이 들지만, <br>
**악의적인 참여자가 부적절한 블록을 추가하거나 기존 블록을 조작하는 것을 방지**할 수 있다.

### 지분 증명

작업 증명 방식은 엄청난 에너지를 소비하기에 대안으로 나온 것이 **"지분 증명 알고리즘"**이다.

> 간단히 말하면 작업이 아닌 더 많은 지분(코인)을 가지고 있을수록 그에 비례하여 블록에 기록할 권한이 더 주어지는 것이다.
{: .prompt-info}

새로운 블록을 검증할 때 검증자 Validator 풀의 투표로 정하는 방법니다.

<u>검증자 풀에서 떠나기 전까지 이더를 예치하면</u> 누구나 검증자 풀에 들어갈 수 있다.
- 각 노드들의 투표는 예치된 금액만큼 가중치를 가진다. (검증자 풀에 노드가 스테이킹한 양과 동일)
    - 더 많은 지분(stake)을 가지는 사람이 더 큰 가중치를 가지는 것.
    - 스테이킹: 네트워크를 보호하기 위해 암호화폐를 잠그고 그에 대한 이자를 받는 행위

이 방법에서 검증자는 송금자가 지불하는 거래 수수료에서 이익을 얻으며, <br> 
검증자가 부정행위를 하면 예치된 이더는 네트워크 내에서 없어지고 소유자는 검증자 풀 가입이 제한된다.
- 이러한 조치를 조작을 예방함.

### 머클 트리와 머클 루트

일반적으로 채굴자는 아래 사진과 같이 블록을 헤더 header와 보디 body 두 부분으로 배치한다.

<table>
    <tr>
        <td>
        <img width="400" src="/assets/img/2024-12-12-blockchain-introduction/12.png">
        </td>
        <td>
            <ul>
                <li>
                    헤더 header
                    <ul>
                        <li>블록 번호 Block number</li>
                        <li>타임스탬프 Timestamp</li>
                        <li>직전 블록의 암호화된 해시값 Previous block's hash 참조</li>
                        <li>논스</li>
                        <li>등등 블록의 메타데이터</li>
                        <li>채굴자가 생성한 트랜잭션의 머클트리 <br> transactions Merkle tree</li>
                        <li>머클 루트 Merkle root</li>
                    </ul>
                </li>
                <li>
                    보디 body
                    <ul>
                        <li>블록 내부의 모든 트랜잭션</li>
                    </ul>
                </li>
            </ul>
        </td>
    </tr>
</table>

<br>

> 트랜잭션 머클 트리 구조는 다음과 같다.

<table>
    <tr>
        <td>
        <img width="400" src="/assets/img/2024-12-12-blockchain-introduction/13.png">
        </td>
        <td>
            <ul>
                <li>블록의 트랜잭션들은 짝을 지어 제일 하단에 위치한다.</li>
                <li>트랜잭션들을 해시한 값은 머클 트리의 잎이 된다.</li>
                <li>각 해시값은 또 짝을 지어 새로운 해시를 생성한다.</li>
                <li>
                    오직 두 개의 해시값이 남을 때까지 반복하여 작업한다. <br>
                    <u>최종적으로 남은 두 개의 값을 해시하면</u> <b>머클루트</b>가 된다.
                </li>
            </ul>
        </td>
    </tr>
</table>

따라서 머클 루트는 블록에 포함된 **모든 트랜잭션**을 **하나의 해시로 요약**하여 **무결성**을 보장한다. 

#### 가벼운 동기화

블록 헤더가 머클 루트를 가지면 클라이언트가 네트워크 피어에서 **전체 트랜잭션이 아닌 블록 헤더를 검색**하여 블록체인을 더 빠르게 동기화 할 수 있다.

## 이더리움 기술

비트코인과 같은 초기 블록체인에서도 스마트 컨트랙트를 구현함. 이후에 나온 이더리움, Nxt와 같은 블록체인들은 스마트 컨트랙트를 더욱 쉽게 작성하고 실행할 수 있도록 하였음. 따라서 이와같은 플랫폼을 스마트 블록체인 또는 블록체인 2.0으로 간주한다.

### 이더리움 블록체인

앞서 설명한 블록 메타데이터를 포함한 헤더 + 트랜잭션을 포함한 바디 구조에서 더 발전된 구조이다.

#### 머클 패트리샤 트라이 Merkle-Patricia trie

머클 트라이보다 작고 효율적인 머클 패트리샤 트라이라는 트랜잭션을 더 작고 효율적인 구조로 해시하는 방법을 사용한다.

![img](/assets/img/2024-12-12-blockchain-introduction/14.png){: w="500" }{: .shadow }
_이더리움의 발전된 블록 헤더_

**블록 헤더 구성**

1. 트랜잭션 정보의 머클 패트리샤 트라이
1. 부가적인 트랜잭션 정보 receipt
3. 현재 블록체인 상태 정보 state

<br>

이 세가지 속성을 통해 다음 사항을 효율적으로 확인할 수 있다.

1. 어떤 트랜잭션이 어떤 특정한 블록에 포함되었는지
2. 한 트랜잭션의 결과가 무엇인지
3. 어떤 계정이 존재하는지
4. 어떤 계정에 잔액이 얼마나 있는지

<br>

#### 머클 패트리샤 트라이 구조

트라이 trie(또는 접수다 트리 prefix tree)는 일반적으로 키가 문자열인 동적 집합을 저장하는 데 사용하는 정렬된 데이터 구조이다.

트라이의 루트는 빈 문자열이며 노드의 모든 하위 항목에는 **해당 노드와 연관된 문자열의 공통 접두사**가 있다.

<table>
    <tr>
        <td>
        <img width="400" src="/assets/img/2024-12-12-blockchain-introduction/14-1.png"> <br>
        트라이 구조
        </td>
        <td>
        <img width="400" src="/assets/img/2024-12-12-blockchain-introduction/13.png"><br>
        머클 트리
        </td>
    </tr>
</table>

머클 패트리샤 트라이는 트라이와 머클 트리를 결합한 데이터 구조이다.

D.R. 모리슨이 설계한 패트리샤 알고리즘(알파벳으로 코딩된 정보를 검색하는 실제 알고리즘)으로 노드 키를 저장해 머클 트리의 효율성을 향상시킨다.

#### 이더리움 노드의 블록 처리 과정

![img](/assets/img/2024-12-12-blockchain-introduction/15.png){: w="400" }{: .shadow }
_이더리움 노드의 블록 처리 과정_

> 전체 노드가 새로운 블록을 수신할 때 본문에 포함된 트랜잭션은 다음과 같이 처리한다.

1. 전체 노드가 새 블록을 받는다.
2. header와 body가 분리된다.
3. 수신한 블록에 포함된 트랜잭션을 정렬하여 **새로운 트랜잭션 머클 패트리샤 트라이**를 생성한다.
4. 트랜잭션들은 EVM에서 실행된다.
    - 이 과정에 부가 트랜잭션 정보를 생성한다.
    - 또한, 전역 state를 변경한다.
5. 4번 과정에서 생성된 부가 트랜잭션 정보 (즉, receipt)를 통해 새로운 **부가 트랜잭션 머클 패트리샤 트라이 Receipts Merkle-Patricia trie**를 생성한다.
6. 4번 과정에서 전역 state를 변경하면서 각 노드에 하나의 인스턴스만 존재하는 **전역 상태 트라이 State Merkle-Patricia trie**를 변경한다.
7. 로컬에서 계산된 receipt, state, Tx 트라이 루트는 헤더의 루트와 비교한다.
8. 로컬에서 계산된 루트와 헤더의 각 루트가 일치하면 블록이 검증된 것으로 간주한다. <br>
    그리고 새로운 트라이 또는 변경된 트라이를 전체 노드에 저장한다.
9. 유효성 검증을 성공적으로 완료하면 NoSQL DB인 LevelDB에 키-값의 형태로 저장된다.
    - receipt, Tx 트라이는 각각 receipt, Tx 저장소에 **추가된다**.
    - 변경된 state 트라이는 state 저장소에 **업데이트된다**.

|  | 트랜잭션 저장소 <br> transaction store | 부가 트랜잭션 정보 저장소 <br> receipts store | 상태 저장소 <br> state store |
|---|---|---|---|
|**키** | 트랜잭션의 해시값 | 트랜잭션 receipt의 해시값 | 계정 주소 (160바이트)|
|**특징**| 블록당 하나의 트랜잭션 트라이를 포함하여 <br> 각 트라이는 변경할 수 없음. | 블록마다 트랜잭션 트라이가 포함되어 <br> 있으며 각 트라이는 변경할 수 없음. | 새 블록이 블록체인에 <br> 추가될 때마다 업데이트 됨.

- **트랜잭션 저장소 transaction store**
    - 키 = 트랜잭션의 해시값
    - 블록당 하나의 트랜잭션 트라이를 포함하여 각 트라이는 변경할 수 없음.
- **부가 트랜잭션 정보 저장소 receipts store**
    - 키 = 트랜잭션 receipt의 해시값
    - 블록마다 트랜잭션 트라이가 포함되어 있으며 각 트라이는 변경할 수 없음.
- **상태 저장소 state store**
    - 키 = 계정 주소 (160바이트)
    - 최신 전역 상태를 나타내는 단일 상태 트라이가 포함됨.
    - 새 블록이 블록체인에 추가될 때마다 업데이트 됨.

#### 이더리움 블록체인 디자인의 장점

세가지 유형의 동기화가 가능함.

1. **전체 동기화** <br>
    클라이언트는 전체 블록체인을 다운로드하고 모든 블록을 로컬에서 검증한다. <br>
    시간이 가장 오래 걸리지만 로컬에서 복사된 블록체인이 무결하다는 것을 확신할 수 있다.
2. **빠른 동기화** <br>
    클라이언트는 전체 블록체인을 다운로드하지만 동기화를 시작하기 전 혹은 새 블록이 생성되기 전에 **64개의 블록만을 검증**한다.
3. **가벼운 동기화** <br>
    클라이언트는 피어 전체 노드에서 블록체인의 **현재 상태 트라이**를 받아 로컬에 저장한다. <br>
    피어들로부터 어떠한 과거 블록도 받지 않고 **새로 생성되는 블록만 수신**하기 때문에 클라이언트를 빠르게 실행할 수 있다.

### EVM

EVM 이더리움 가상머신. 

이더리움 P2P 네트워크의 각 노드에서 실행되며 어떤 복잡한 코드라도 실행할 수 있어 튜링 완전하다.

> **튜링 완전 turing completeness** <br>
> 어떤 프로그래밍 언어나 추상 머신이 튜링 머신과 동일한 계산 능력을 가진다는 의미이며 <br>
> 튜링 머신으로 풀 수 있는 문제, 즉 계산적인 문제를 그 프로그래밍 언어나 추상 머신으로 풀 수 있다는 의미
{: .prompt-info}

- 블록체인 데이터를 읽거나 쓸수 있으며
- 전자서명이 유효하고
- 블록체인의 현재 상태에 기반한 제약 조건이 만족되는 경우에만 코드를 실행함.

### 스마트 컨트랙트

탈중앙화 앱의 로직을 캡슐화한다.

솔리디티와 서펜트와 같은 고급 언어로 작성되며 EVM 바이트 코드로 컴파일된다.

P2P 네트워크 상의 각 노드에 배포되고 EVM에서 실행된다.

### 차세대 블록체인

EVM 덕분에 프로그램이 가능하기에 암호화폐뿐만 아니라 모든 유형의 탈중앙화 앱 개발이 가능하다.

더 나아가 스마트 블록체인 플랫폼이 차세대 Web 3.0의 기초가 될 것이라고 주장하는 사람들도 있다.

# 요약

- 이더리움 노드 = 이더리움 클라이언트 + 블록체인 복사본
- 이더리움 클라이언트
    - 이더리움 가상머신 EVM : 스마트 컨트랙트 바이트코드를 실행
    - 메모리 풀 : 네트워크로 전파하기 전에 수신한 트랜잭션을 저장하는 장소
    - JSON-RPC API : 다른 노드나 외부 사용자가 클라이언트에 접근할 수 있는 인터페이스
    - 클라이언트 프로세스 : 거래를 처리하는 곳
- 이더리움 스마트 컨트랙트는 솔리디티로 작성되며 EVM 바이트코드로 컴파일된다.
- 이더리움 스마트 컨트랙트는 배포 트랜잭션을 통해 P2P 네트워크로 배포된다. 로컬 이더리움 노드로 전송되고 다시 네트워크로 전파된다.
- 블록체인은 일련의 블록이다.
    - 블록 = 시퀀스 번호 + 타임스탬프 + 디지털 서명된 트랜잭션 목록 + 이전 블록의 해시값 + 현재 블록의 해시값을 결정하는 논스
- 이더리움이 가져온 주요 혁신
    - EVM
    - 스마트 컨트랙트


---

> 「Building Ethereum Dapps 이더리움 디앱 개발」 (로베르토 인판테 저, 정종화 역)을 읽고 작성한 글입니다.
{: .prompt-tip}